# -*- coding: utf-8 -*-
"""SD_Trabalho1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RPV5NnaZyclOvuIgaOlfv3UnL6lRglW_
"""

!pip install protobuf==3.20.*

#.proto
syntax = "proto3";

package smart_home;

// Representa o estado de um dispositivo TV
message TVState {
  string power = 1;      // Estado de energia (on/off)
  int32 volume = 2;      // Volume atual
  int32 channel = 3;     // Canal atual
}

// Representa o estado de um dispositivo Ar Condicionado
message ACState {
  string power = 1;      // Estado de energia (on/off)
  int32 temperature = 2; // Temperatura atual
}

// Representa o estado de uma Lâmpada
message LampState {
  string power = 1;      // Estado de energia (on/off)
}

// Representa os dados de um Sensor de Temperatura
message TemperatureSensorData {
  float temperature = 1; // Temperatura medida
}

// Mensagem de descoberta de dispositivo
message DeviceDiscovery {
  string device_type = 1; // Tipo do dispositivo (TV, AC, Lamp, Sensor)
  string ip = 2;          // Endereço IP do dispositivo
  int32 port = 3;         // Porta do dispositivo
}

// Comandos enviados para os dispositivos
message DeviceCommand {
  string device_type = 1; // Tipo do dispositivo (TV, AC, Lamp, Sensor)
  string action = 2;      // Ação a ser realizada (e.g., ligar, desligar, aumentar, diminuir)
  string parameter = 3;   // Parâmetro adicional (e.g., canal ou temperatura)
}

// Resposta dos dispositivos ao Gateway
message DeviceResponse {
  string device_type = 1; // Tipo do dispositivo
  string status = 2;      // Estado atualizado ou confirmação
}

#gateway
import socket
import threading
from smart_home_pb2 import DeviceDiscovery, DeviceCommand, DeviceResponse

# Configurações do multicast
MULTICAST_GROUP = '224.0.0.1'
MULTICAST_PORT = 5007

# Configurações do servidor TCP
TCP_HOST = '0.0.0.0'
TCP_PORT = 6000

# Armazena os dispositivos descobertos
devices = {}


def send_multicast():
    """Envia mensagem multicast para descobrir dispositivos."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock:
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
        discovery_message = "Discover devices"
        sock.sendto(discovery_message.encode(), (MULTICAST_GROUP, MULTICAST_PORT))
    print("Mensagem multicast enviada.")


def udp_listener():
    """Recebe mensagens UDP de descoberta de dispositivos."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.bind(('', MULTICAST_PORT))
        while True:
            data, addr = sock.recvfrom(1024)
            print(f"Dados recebidos: {data}")
            if len(data) > 0:
                try:
                    discovery = DeviceDiscovery()
                    discovery.ParseFromString(data)
                    devices[discovery.device_type] = {
                        "ip": discovery.ip,
                        "port": discovery.port
                    }
                    print(f"Dispositivo descoberto: {discovery}")
                except Exception as e:
                    print(f"Erro ao desserializar dados: {e}")


def handle_tcp_client(client_socket):
    """Gerencia conexões TCP com o cliente."""
    while True:
        try:
            data = client_socket.recv(1024)
            if not data:
                break
            command = DeviceCommand()
            command.ParseFromString(data)
            print(f"Comando recebido: {command}")

            # Enviar o comando ao dispositivo correspondente
            if command.device_type in devices:
                device = devices[command.device_type]
                forward_command_to_device(command, device["ip"], device["port"], client_socket)
            else:
                print(f"Dispositivo {command.device_type} não encontrado.")
        except Exception as e:
            print(f"Erro ao processar comando TCP: {e}")
    client_socket.close()


def forward_command_to_device(command, device_ip, device_port, client_socket):
    """Encaminha o comando para o dispositivo especificado."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as device_socket:
            device_socket.connect((device_ip, device_port))
            device_socket.send(command.SerializeToString())
            response_data = device_socket.recv(1024)
            response = DeviceResponse()
            response.ParseFromString(response_data)
            print(f"Resposta do dispositivo: {response}")
            client_socket.send(response.SerializeToString())
    except Exception as e:
        print(f"Erro ao encaminhar comando ao dispositivo: {e}")


def start_tcp_server():
    """Inicia o servidor TCP."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind((TCP_HOST, TCP_PORT))
        server.listen(5)
        print("Servidor TCP aguardando conexões...")
        while True:
            client_socket, addr = server.accept()
            print(f"Cliente conectado: {addr}")
            threading.Thread(target=handle_tcp_client, args=(client_socket,)).start()


# Iniciar serviços
threading.Thread(target=udp_listener, daemon=True).start()
threading.Thread(target=start_tcp_server, daemon=True).start()
send_multicast()

#TV
import socket
from smart_home_pb2 import DeviceDiscovery, DeviceCommand, DeviceResponse, TVState

DEVICE_TYPE = "TV"
TCP_PORT = 7000
UDP_PORT = 5007
GATEWAY_IP = "54.91.152.94"  # IP público do Gateway

state = {"power": "off", "volume": 10, "channel": 1}


def respond_to_discovery():
    """Responde à mensagem multicast de descoberta do Gateway."""
    discovery = DeviceDiscovery(
        device_type=DEVICE_TYPE,
        ip=socket.gethostbyname(socket.gethostname()),
        port=TCP_PORT
    )
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
        sock.sendto(discovery.SerializeToString(), (GATEWAY_IP, UDP_PORT))
    print("Resposta de descoberta enviada.")


def handle_command(command):
    """Trata comandos recebidos do Gateway."""
    global state
    if command.action == "turn_on":
        state["power"] = "on"
    elif command.action == "turn_off":
        state["power"] = "off"
    elif command.action == "volume_up":
        state["volume"] += 1
    elif command.action == "volume_down":
        state["volume"] -= 1
    elif command.action == "change_channel":
        state["channel"] = int(command.parameter)
    return TVState(power=state["power"], volume=state["volume"], channel=state["channel"])


def start_tcp_server():
    """Inicia o servidor TCP para receber comandos."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind(('0.0.0.0', TCP_PORT))
        server.listen(5)
        print(f"{DEVICE_TYPE} aguardando comandos...")
        while True:
            client_socket, addr = server.accept()
            with client_socket:
                data = client_socket.recv(1024)
                if not data:
                    continue
                command = DeviceCommand()
                command.ParseFromString(data)
                response_state = handle_command(command)
                response = DeviceResponse(
                    device_type=DEVICE_TYPE,
                    status=response_state.SerializeToString()
                )
                client_socket.send(response.SerializeToString())


# Iniciar serviços
respond_to_discovery()
start_tcp_server()

#Ar condicionado
import socket
from smart_home_pb2 import DeviceDiscovery, DeviceCommand, DeviceResponse, ACState

DEVICE_TYPE = "AC"
TCP_PORT = 7001
UDP_PORT = 5007
GATEWAY_IP = "54.91.152.94"

state = {"power": "off", "temperature": 24}


def respond_to_discovery():
    """Responde à mensagem multicast de descoberta do Gateway."""
    discovery = DeviceDiscovery(
        device_type=DEVICE_TYPE,
        ip=socket.gethostbyname(socket.gethostname()),
        port=TCP_PORT
    )
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
        sock.sendto(discovery.SerializeToString(), (GATEWAY_IP, UDP_PORT))
    print("Resposta de descoberta enviada.")


def handle_command(command):
    """Trata comandos recebidos do Gateway."""
    global state
    if command.action == "turn_on":
        state["power"] = "on"
    elif command.action == "turn_off":
        state["power"] = "off"
    elif command.action == "temp_up":
        state["temperature"] += 1
    elif command.action == "temp_down":
        state["temperature"] -= 1
    return ACState(power=state["power"], temperature=state["temperature"])


def start_tcp_server():
    """Inicia o servidor TCP para receber comandos."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind(('0.0.0.0', TCP_PORT))
        server.listen(5)
        print(f"{DEVICE_TYPE} aguardando comandos...")
        while True:
            client_socket, addr = server.accept()
            with client_socket:
                data = client_socket.recv(1024)
                if not data:
                    continue
                command = DeviceCommand()
                command.ParseFromString(data)
                response_state = handle_command(command)
                response = DeviceResponse(
                    device_type=DEVICE_TYPE,
                    status=response_state.SerializeToString()
                )
                client_socket.send(response.SerializeToString())


# Iniciar serviços
respond_to_discovery()
start_tcp_server()

#lampada
import socket
from smart_home_pb2 import DeviceDiscovery, DeviceCommand, DeviceResponse, LampState

DEVICE_TYPE = "Lamp"
TCP_PORT = 7002
UDP_PORT = 5007
GATEWAY_IP = "54.91.152.94"

state = {"power": "off"}


def respond_to_discovery():
    """Responde à mensagem multicast de descoberta do Gateway."""
    discovery = DeviceDiscovery(
        device_type=DEVICE_TYPE,
        ip=socket.gethostbyname(socket.gethostname()),
        port=TCP_PORT
    )
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
        sock.sendto(discovery.SerializeToString(), (GATEWAY_IP, UDP_PORT))
    print("Resposta de descoberta enviada.")


def handle_command(command):
    """Trata comandos recebidos do Gateway."""
    global state
    if command.action == "turn_on":
        state["power"] = "on"
    elif command.action == "turn_off":
        state["power"] = "off"
    return LampState(power=state["power"])


def start_tcp_server():
    """Inicia o servidor TCP para receber comandos."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind(('0.0.0.0', TCP_PORT))
        server.listen(5)
        print(f"{DEVICE_TYPE} aguardando comandos...")
        while True:
            client_socket, addr = server.accept()
            with client_socket:
                data = client_socket.recv(1024)
                if not data:
                    continue
                command = DeviceCommand()
                command.ParseFromString(data)
                response_state = handle_command(command)
                response = DeviceResponse(
                    device_type=DEVICE_TYPE,
                    status=response_state.SerializeToString()
                )
                client_socket.send(response.SerializeToString())


# Iniciar serviços
respond_to_discovery()
start_tcp_server()

#sensor de temperatura
import socket
from smart_home_pb2 import DeviceDiscovery, DeviceResponse, TemperatureSensorData
import random
import time

DEVICE_TYPE = "Sensor"
TCP_PORT = 7003
UDP_PORT = 5007
GATEWAY_IP = "54.91.152.94"

def respond_to_discovery():
    """Responde à mensagem multicast de descoberta do Gateway."""
    discovery = DeviceDiscovery(
        device_type=DEVICE_TYPE,
        ip=socket.gethostbyname(socket.gethostname()),
        port=TCP_PORT
    )
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
        sock.sendto(discovery.SerializeToString(), (GATEWAY_IP, UDP_PORT))
    print("Resposta de descoberta enviada.")


def send_temperature():
    """Envia leituras periódicas de temperatura ao Gateway."""
    while True:
        temperature = round(random.uniform(18.0, 30.0), 2)
        sensor_data = TemperatureSensorData(temperature=temperature)
        print(f"Temperatura medida: {temperature}°C")
        time.sleep(5)  # Envia a cada 5 segundos


# Iniciar serviços
respond_to_discovery()
send_temperature()

#cliente
import socket
from smart_home_pb2 import DeviceCommand, DeviceResponse

GATEWAY_IP = "54.91.152.94"  # IP público do Gateway
GATEWAY_TCP_PORT = 6000

def send_command(device_type, action, parameter=""):
    """Envia um comando para o Gateway."""
    command = DeviceCommand(
        device_type=device_type,
        action=action,
        parameter=parameter
    )
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
            client_socket.connect((GATEWAY_IP, GATEWAY_TCP_PORT))
            client_socket.send(command.SerializeToString())
            response_data = client_socket.recv(1024)
            response = DeviceResponse()
            response.ParseFromString(response_data)
            print(f"Resposta do Gateway: {response.status}")
    except Exception as e:
        print(f"Erro ao enviar comando: {e}")


def main():
    """Interface simples para interagir com o sistema."""
    print("Cliente iniciado. Digite os comandos:")
    while True:
        print("\nDispositivos disponíveis: TV, AC, Lamp, Sensor")
        device_type = input("Digite o tipo do dispositivo: ").strip()
        action = input("Digite a ação (e.g., turn_on, turn_off, volume_up): ").strip()
        parameter = input("Digite o parâmetro (opcional, e.g., canal ou temperatura): ").strip()
        send_command(device_type, action, parameter)


if __name__ == "__main__":
    main()